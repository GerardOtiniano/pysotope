import pandas as pdimport numpy as npimport osimport matplotlib.pyplot as pltfrom . .regression import wls_regressionfrom . .queries import *import statsmodels.api as smfrom statsmodels.sandbox.regression.predstd import wls_prediction_stdfrom . .figures import standard_check_figuresdef vsmow_correction(cfg, unknown, lin, drift, correction_log, folder_path, fig_path, log_file_path, isotope, vsmow, fig=True):    print("Applying VSMOW correction")    if isotope == "dD":        label = "dD"    else:        label = "dC"    # Copy standards    lin_ = lin.copy();     lin_["source_group"] = "linearity"    drift_ = drift.copy(); drift_["source_group"] = "drift"    stds  = pd.concat([lin_, drift_], ignore_index=True)    # Identify standards    standards_iso   = list(vsmow[vsmow['VSMOW accuracy check'] == False]['ID'])    standards_chain = list(vsmow[vsmow['VSMOW accuracy check'] == False]['chain length'])    vsmow_check     = np.array(vsmow[vsmow['VSMOW accuracy check'] == True]['chain length']).flat[0]    # Map actual values and their uncertainty onto matched rows    for i, chain in zip(standards_iso, standards_chain):        mask = (stds['Identifier 1'].str.contains(i)) & (stds['chain'] == chain)        stds.loc[mask, 'VSMOW_dD_actual']    = vsmow.loc[vsmow['ID'] == i, 'isotope value'].iloc[0]        stds.loc[mask, 'vsmow_error_actual'] = vsmow.loc[vsmow['ID'] == i, 'std'].iloc[0]        # add a label per standard for balancing        stds.loc[mask, 'std_label'] = f"{i}_C{chain}"    dD_id = cfg.dD_col        stds = stds[~stds[dD_id].isna()].copy()    mask_fit = stds.chain.isin(standards_chain)    # Replicate-based uncertainty    stds['replicate_uncertainty'] = np.nan    for chain_l, std_id in zip(vsmow[vsmow['VSMOW accuracy check'] == False]['chain length'], vsmow[vsmow['VSMOW accuracy check'] == False]['ID']):        chain_mask = (stds['chain'] == chain_l) & (stds['Identifier 1'].str.contains(std_id))        value = np.std(stds.loc[chain_mask, dD_id])        stds.loc[chain_mask, 'replicate_uncertainty'] = value    # WLS weights from uncertainty    # sigma2 = (stds.loc[mask_fit, 'vsmow_error_actual']**2 + stds.loc[mask_fit, 'replicate_uncertainty']**2).astype(float)    # sigma2 = sigma2.fillna(sigma2.median() if np.isfinite(sigma2.median()) else 1.0)    # sigma2 = np.maximum(sigma2, 1e-12)    # Address bug issue    v = pd.to_numeric(stds.loc[mask_fit, 'vsmow_error_actual'], errors='coerce')    r = pd.to_numeric(stds.loc[mask_fit, 'replicate_uncertainty'], errors='coerce')    sigma2 = (v**2 + r**2)    sigma2 = sigma2.astype(float)    sigma2 = sigma2.fillna(sigma2.median() if np.isfinite(sigma2.median()) else 1.0)    sigma2 = np.maximum(sigma2, 1e-12)    w_base = 1.0 / sigma2    # Sum weights per standard group to 1 - balances different number of standard measurements    std_label = stds.loc[mask_fit, 'std_label'].copy()    if std_label.isna().any():        std_label = stds.loc[mask_fit, 'chain'].astype(str)    # Normalize within each std_label    w_bal = w_base.copy()    for lbl, idx in std_label.groupby(std_label).groups.items():        s = w_base.loc[idx].sum()        if s > 0:            w_bal.loc[idx] = w_base.loc[idx] / s        else:            # uniform if degenerate            w_bal.loc[idx] = 1.0 / len(idx)    # WLS regression    x = stds.loc[mask_fit, dD_id].astype(float)    y = stds.loc[mask_fit, 'VSMOW_dD_actual'].astype(float)    w = w_bal    m_d, b_d, r_squared, p_value, std_error, model = wls_regression(x, y, log_file_path, weights=w)    # Predict standards    new_x = sm.add_constant(np.array(stds[dD_id], dtype=float))    stds['VSMOW_dD'] = model.predict(new_x)    prstd, std_pred_ci_lower, std_pred_ci_upper = wls_prediction_std(model, exog=new_x)    stds['VSMOW_error'] = prstd    # Predict samples    new_x = sm.add_constant(np.array(unknown[dD_id], dtype=float))    unknown['VSMOW_dD'] = model.predict(new_x)    prstd, unknown_pred_ci_lower, unknown_pred_ci_upper = wls_prediction_std(model, exog=new_x)    unknown['VSMOW_error'] = prstd    # Accuracy check    relative_standard = vsmow[vsmow['VSMOW accuracy check'] == True]['isotope value'].values    rs_unc            = vsmow[vsmow['VSMOW accuracy check'] == True]['std'].values    fig = plt.figure()    plt.scatter(stds.loc[mask_fit, dD_id], stds.loc[mask_fit, 'VSMOW_dD_actual'],                c='red', ec='k', label=f'VSMOW {standards_iso}', s=80, zorder=2)    plt.plot(stds.loc[mask_fit, dD_id], stds.loc[mask_fit, dD_id]*m_d + b_d,             c='k', linestyle='-', alpha=0.6, zorder=0)    plt.scatter(unknown[dD_id], unknown['VSMOW_dD'], c='k', marker='x', alpha=0.5,                label='corrected samples', zorder=1)    # if isotope == 'dD':    mask_chk = stds.chain == vsmow_check    plt.scatter(stds.loc[mask_chk, dD_id], stds.loc[mask_chk, 'VSMOW_dD'],                c='blue', ec='k', label=f'Predicted {vsmow_check}', zorder=99, s=80)    def as_float(x, name):        try:            return float(np.squeeze(x))        except Exception as e:            raise TypeError(f"{name} must be numeric; got {x!r} (type={type(x)}).") from e    relative_standard = as_float(relative_standard, "relative_standard")    rs_unc = as_float(rs_unc, "rs_unc")    ymin = float(np.squeeze(relative_standard - rs_unc))    ymax = float(np.squeeze(relative_standard + rs_unc))    plt.axhspan(ymin=ymin, ymax=ymax, color='blue', alpha=0.4, zorder=1,                label=f"Actual VSMOW {vsmow_check}")    plt.legend(loc='lower center', bbox_to_anchor=(0.5, -0.3), frameon=False, ncol=2)    plt.xlabel("Measured " + str(label) + " (‰)")    plt.ylabel("Predicted VSMOW " + str(label) + " (‰)")    plt.savefig(os.path.join(fig_path, 'VSMOW correction.png'), dpi=300, bbox_inches='tight')    plt.show()    print("\nRegression statistics VSMOW standards:")    print("Linear equation: " + str(label) + f" = ({m_d:.2f})(time) + {b_d:.2f}")    print(f"Adjusted R²: {r_squared:.2f}")    print(f"p-value: {p_value:.2f}")    print(f"Standard Error: {std_error:.2f}")    print(f"\nAccuracy of {vsmow_check} prediction")    mask_chk = stds.chain == vsmow_check  # "C24"    test = stds.loc[mask_chk, 'VSMOW_dD']    mae = (test - relative_standard).abs().mean()    rmse = np.sqrt(((test - (relative_standard)) ** 2).mean())    print(f"RMSE: {rmse:.2f}")    if 'drift_error' not in stds.columns:        stds['drift_error'] = np.nan    if 'linearity_error' not in stds.columns:        stds['linearity_error'] = np.nan    append_to_log(log_file_path, 'VSMOW')    append_to_log(log_file_path, f"- Linear equation: {label})  = ({m_d:.2f})(time) + {b_d:.2f}")    append_to_log(log_file_path, f"- Adjusted R²: {r_squared:.2f}")    append_to_log(log_file_path, f"- p-value: {p_value:.2f}")    append_to_log(log_file_path, f"- Standard Error: {std_error:.2f}")    append_to_log(log_file_path, f"- Accuracy of C24 prediction (RMSE): {rmse:.2f}")    if isotope=="dD":        standard_check_figures(cfg, stds, fig_path, label, vsmow, isotope)    return unknown, stds